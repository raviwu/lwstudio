<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bitbucket on Ravi Wu</title>
    <link>https://raviwu.github.io/tags/bitbucket/</link>
    <description>Recent content in bitbucket on Ravi Wu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <copyright>Copyright © 2020, Ravi Wu.</copyright>
    <lastBuildDate>Sat, 18 Sep 2021 20:08:30 +0800</lastBuildDate><atom:link href="https://raviwu.github.io/tags/bitbucket/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>安全性靜態掃描工具 sast-scan 與 Bitbucket 整合</title>
      <link>https://raviwu.github.io/posts/sast-scan-integration/</link>
      <pubDate>Sat, 18 Sep 2021 20:08:30 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/sast-scan-integration/</guid>
      <description>安全性掃描一直以來都是有點微妙的存在，之前的公司規定專案要上線要過 Fortify + Blackduck 的掃描，可是這類掃描都得花一點時間，所以就跟跑很慢的 Test 公司所有團隊 一樣，總是淪落為有需要交差的時候才跑，然後每次掃完都得另外撥出時間來修復被掃到的弱點。
這回又遇上一樣的需求，只是這次有機會可以從頭評估，趁這這個勢頭，研究一下有沒有更好整進開發週期，掃描不太慢結果也，是不是就能某種程度上趨近「越痛的事情就要越常做才會慢慢不痛」，展開尋找與探索之旅。
TL;DR  sast-scan 跟 SonarQube 掃出來的結果，安全性項目更多，煩人的假警報較少，掃描大專案的時候比較快。 使用 sast-scan 的 Docker image 配合客製化的 bitbucket pipe 執行掃描結果判讀，可以實現不用花大錢就能提高系統安全性信心，而且還能滿足初步的 Rule 客製化的需求。  sast-scan 與 SonarQube 實際上拿了一些專案來掃，幾個發現記錄一下：
 SonarQube 跟 sast-scan 掃出來的東西用檔案名稱跟行數去對，重疊率在 5% 以下 SonarQube 的預設掃描規則，有一大部分是類似 Linter 的 Code Smell 項目 SonarQube 的 Docker image 跑在 local 的話 Docker 的記憶體不給高一點會爆，因為 SonarQube 的 embed ElasticSearch DB 需要至少 2G 的資源來跑，後來用 docker run -d -m 8G --name sonarqube -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true -p 9000:9000 sonarqube:8.</description>
    </item>
    
  </channel>
</rss>
