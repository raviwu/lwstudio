<!DOCTYPE html>
<html lang="zh-tw">
    <head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<title>coding &middot; Ravi Wu</title>

		
  		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="/tags/coding/index.xml" rel="alternate" type="application/rss+xml" title="Ravi Wu" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					<h2 class="nav-title">Ravi Wu</h2>
				</a>
				<ul>
    
    
        <li>
            <a href="/posts/">
                
                <span>Posts</span>
                
            </a>
        </li>
    
        <li>
            <a href="/tags/">
                
                <span>Tags</span>
                
            </a>
        </li>
    
        <li>
            <a href="https://www.linkedin.com/in/raviwu">
                
                <span>Linkedin</span>
                
            </a>
        </li>
    
        <li>
            <a href="https://github.com/raviwu">
                
                <span>GitHub</span>
                
            </a>
        </li>
    
</ul>
			</div>
		</nav>

        

<main>
    <h1>Tag coding</h1>
	<div class="catalogue">
		
			<a href="https://raviwu.github.io/posts/go-type/" class="catalogue-item">
    <div>
        <time datetime="2020-10-28 12:05:03 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">Go | 型別（Type）</h1>
        <div class="catalogue-line"></div>

        <p>
            Go 的型別（Type）可以讓編譯器知道兩樣資訊：
 需要使用的記憶體大小 這些記憶體所代表的內容  以內建的型別為例：
   型別 記憶體大小 內容     int64 8 bytes 整數   float32 4 bytes IEEE-754 浮點數   bool 1 byte true OR false    有一些型別所代表的內容會跟著 build 機器的不同架構有所差異，例如同樣的 int 在 64 位元電腦裡佔 8 bytes 但在 32 位元電腦裡只佔 4 bytes。
自定義型別 Go 容許自定義型別，最簡單的宣告方式為 struct
type user struct { name string email string ext int isAdmin bool } 使用 var ravi user 可以宣告一個 ravi 的變數，代表一個 user 型別。宣告的當下，型別的欄位值會使用各欄位之型別的零值。
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/go-map/" class="catalogue-item">
    <div>
        <time datetime="2020-10-26 14:42:56 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">Go | Map</h1>
        <div class="catalogue-line"></div>

        <p>
            Go 的 map 是鍵值對的資料結構。
// 宣告一個空白 map colors := map[string]string{} // 加入或修改鍵值對 colors[&#34;Yello&#34;] = &#34;#cc8500&#34; // 刪除鍵值（鍵不存在時並不會噴錯誤） delete(colors, &#34;Red&#34;) // 宣告一個空 map var numbers map[int]string numbers[1] = &#34;One&#34; // panic: runtime error: assignment ot entry in nil map 檢查鍵是否存在，如果指定的鍵不存在，會回傳零值給 value
value, exists := colors[&#34;Blue&#34;] if exists { fmt.Println(value) } else { fmt.Println(value) // &#34;&#34; } 迭代 map numbers := map[int]string{ 1: &#34;one&#34;, 2: &#34;two&#34;, 3: &#34;three&#34;, } for key, value := range numbers { fmt.
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/go-slice/" class="catalogue-item">
    <div>
        <time datetime="2020-10-26 13:14:21 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">Go | 切片（Slice）</h1>
        <div class="catalogue-line"></div>

        <p>
            切片（Slice）是操作其指向之陣列（Array）的物件。
[指標|長度|最大長度] // 切片 | [1,2,3,4,5] // 陣列 切片的初始化 // 宣告一個長度與最大長度都是 5 的字串陣列 slice1 := make([]string, 5) // 宣告一個長度為 3 最大長度為 5 的整數陣列 slice2 := make([]int, 3, 5) 長度不能大於最大長度，不然編譯器會噴錯誤。一般來說，宣告切片的同時也會同時賦值：
// 宣告一個長度與最大長度為 3 的切片 slice1 := []string{&#34;One&#34;, &#34;Two&#34;, &#34;Three&#34;} // 宣告一個長度與最大長度為 100 的切片 slice2 := []string{99: &#34;&#34;} 空切片（nil slice）與空白切片（empty slice） 不管是空切片還是空白切片，標準函式庫裡的 append 、 len 跟 cap 的使用行為都一樣。
空切片（nil slice） 在 Go 程式中，空切片很常出現，通常被當成不存在資料時的回傳值，例如 return nilSlice, error。
空切片的宣吿方式：
var slice []int 空切片長成這樣：
   位置 0 1 2     用途 指標 長度 最大長度   值 nil 0 0    空白切片（empty slice） 空白切片通常是用來表達零資料集合，例如查詢資料庫後回傳零筆資料。空白切片的指標指向空陣列，所以並不會另外佔用記憶體。
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/go-array/" class="catalogue-item">
    <div>
        <time datetime="2020-10-26 11:36:46 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">Go | 陣列（Array）</h1>
        <div class="catalogue-line"></div>

        <p>
            Go 的陣列是連續空間內儲存了固定數目之相同型別物件的容器。當使用 var array [5]int 宣告時，陣列內儲存的型別或者長度都不能再改變，如果需要更多的空間來儲存新的物件，需要宣告一個新的陣列後把原先的值搬過去新的陣列。
在 Go 語言中宣告新的變數且無賦值時，這些變數所指向的物件都會以其零值（Zero Value）初始化。有關於 Go 的零值，請參考這邊。常用的零值：
   類型 零值     數值 0   布林值 false   字串 &quot;&quot;    初始化陣列的同時賦值 // 宣告一個 array1 變數的 int 陣列，長度為 5 且值依序分別為 1,2,3,4,5 array1 := [5]int{1,2,3,4,5} // 宣告一個 array2 變數的 int 陣列，長度為 5 且值依序分別為 0,1,2,0,0 array2 := [5]int{1: 1, 2: 2} // 宣告一個 array3 變數的 int 陣列，長度為取決於賦值內容 // 如以下 array3 的長度為 3 array3 := [.
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/java-inputstream-datainputstream-and-bufferedinputstream/" class="catalogue-item">
    <div>
        <time datetime="2020-09-11 13:46:57 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">InputStream 、 DataInputStream 與 BufferedInputStream</h1>
        <div class="catalogue-line"></div>

        <p>
            Java 有很多不同的 InputStream 類別，老是搞不清楚，InputStream、DataInputStream跟BufferedInputStream最近出現在我看的書的練習題裡，一些從 Java Doc (1.8) 文件中拉出來的相關連結：
 Closeable FilterInputStream InputStream DataInputStream BufferedInputStream  InputStream是抽象類別，實踐了Closeable，所以可以當成try with resource裡的資源。類別方法裡定義了InputStream.nullInputStream()可以產生空的InputStream。另外也規範所有實作子類別必須提供public int read() throws IOException方法來回傳下一個 byte 的內容。
FilterInputStream在生成時吃進InputStream後把InputStream存起來，並且覆寫了所有InputStream裡的方法，大部分覆寫的方法都是把原來的操作轉到物件生成時丟進去的InputStream上，以供更細分的子類別使用，例如：
public int read(byte b[], int off, int len) throws IOException { return in.read(b, off, len); } DataInputStream跟BufferedInputStream都進一步繼承FilterInputStream。DataInputStream主要是從InputStream直接讀入 Java 的 primitive data type。
BufferedInputStream在內部會產生一個緩衝陣列（buffer array）來支援mark跟reset方法，透過額外使用的緩衝空間來先讀入資料，以優化資料讀入的效能。
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/java-generic-functional-interface-specilization/" class="catalogue-item">
    <div>
        <time datetime="2020-09-11 13:44:04 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">泛型 Java Functional Interface 的特規化</h1>
        <div class="catalogue-line"></div>

        <p>
            如果某個特殊型別的 Functional Interface 常常被使用時，有時候直接宣告型別會比較方便引用。可以透過兩種方式來做特規，介面與抽象類別：
Generic Functional Interface
@FunctionalInterface public interface TwoArgsProcessor&lt;X&gt; { X process(X arg1, X arg2); } 介面（Interface）
@FunctionalInterface public interface TwoIntsProcessor extends TwoArgsProcessor&lt;Integer&gt; { } 抽象類別（Abstract Class）
abstract class TwoIntsProcessorAbstract implements TwoArgsProcessor&lt;Integer&gt; { } 
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/java-use-combo-condition-for-loop/" class="catalogue-item">
    <div>
        <time datetime="2020-09-10 13:41:31 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">使用複合條件來判斷是否進入下一輪 Java 迴圈</h1>
        <div class="catalogue-line"></div>

        <p>
            在 Java 迴圈寫法中，假如我想要透過一個外部判斷來提前中斷這個迴圈，之前我習慣寫：
public class Test { public static void main(String[] args) { int [] ints = {1,2,3,4,5}; boolean continueCond = true; for (int i=0; i&lt;ints.length; i++) { continueCond = ints[i] &lt; 4; if (!continueCond) break; System.out.println(ints[i]); } } } 但這樣寫其實有點冗，今天看到在 Functional Interfaces in Java 裡的一個範例寫法：
public class Test { public static void main(String[] args) { int [] ints = {1,2,3,4,5}; boolean continueCond = true; for (int i=0; i&lt;ints.length &amp;&amp; continueCond; i++) { continueCond &amp;= ints[i] &lt; 4; System.
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/tools-scoop-sh/" class="catalogue-item">
    <div>
        <time datetime="2018-08-10 13:39:10 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">Windows 裡的類 homebrew 工具： scoop.sh</h1>
        <div class="catalogue-line"></div>

        <p>
            新工作的環境是 Windows 系統，所有的開發工具生態系都要重新摸索。剛開始發現可以用 Git for Windows 裝好後的 console 下平常習慣的 bash 指令後，努力想要自己寫一些 shell script 去自動化開發工具跟環境變數的初始化，簡單的情境下好似都還堪用。
可是如果要安裝的套件都要一個一個手刻 script 好像又有些白癡。
因緣際會下被提點去找其他平台上的類 Homebrew 方案，權衡系統權限低落等實際情況下，好像也只剩 scoop.sh 可以用了。
搞了一整天反覆試驗了一陣子，總算是把裝機清單給列了出來，放在這裡。雖然還是要手動輸入指令，但是可以統一管理這些套件，用指令反安裝等已經比之前的原始人狀態進步多了。
被 oh my zsh 慣壞眼睛的我，有幸發現可以用 concfg 稍微把 PowerShell 的顏色弄得順眼一點。所謂山不轉路轉，路不轉人轉，接下來還需要努力爬行。（握拳）
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/testing-rake-task-in-rspec/" class="catalogue-item">
    <div>
        <time datetime="2017-05-07 13:36:08 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">在 RSpec 裡測試 Rake Task</h1>
        <div class="catalogue-line"></div>

        <p>
            最近被 Rake Task 的測試設定搞得一頭霧水，簡單記錄一下測試 Rake Task 的測試設定，以及各種鬼打牆的血淚史：
TL;DR 為了避免各種 task 載入、執行狀態等相互干擾導致 test case 會偶發性失敗，每一次執行 test case 時就去做「載入」、「卸載」會比較沒有鬼打牆狀況出現。
# spec_helper.rb config.before(:each, rake: true) do Rails.application.load_tasks end config.after(:each, rake: true) do Rake::Task.clear end 把 Rails.application.load_tasks 放在 before(:each) 確保每次載入 test case 前都有正確 load 到要測試的那隻 task ，並在 after(:each) 時用 Rake::Task.clear 去清空剛剛載入的 Rake Task。
透過 rake: true 這個 flag 可以避免其他不相關的單元測試也去載入 Rake Task。
透過每個 each 都做載入跟卸載 Rake Task 後，就可以在 test case 單純使用 Rake::Task['task_name'].invoke 來手動執行 Task 而不用另外去作載入或卸載。
        </p>
    </div>
</a>

		
			<a href="https://raviwu.github.io/posts/notes-soft-skills/" class="catalogue-item">
    <div>
        <time datetime="2017-02-22 13:28:15 &#43;0800 CST" class="catalogue-time"></time>
        <h1 class="catalogue-title">書摘 | Soft Skills = The software developer&#39;s life manual</h1>
        <div class="catalogue-line"></div>

        <p>
            公司前輩分享了 Soft Skills: The software developer&rsquo;s life manual 這本書，後來又在 Soft &amp; Share 看到推廣介紹，抱著當休閒讀物的心情來閱讀是很不錯的。
作者 John Z. Sonmez 在這本書中想要涵括的內容實在包山包海，如果對於人生迷惘的捧油，的確只要看了這本書所簡單介紹的內容就大概可以對人生重拾一些希望，也能循著這些主題繼續往深探索。比較特別的是，每個章節的篇幅被設計成大概一篇 Blog 文長度，所以閱讀起來的節奏感很是不錯，即使有些主題令人打哈欠，有些主題不斷地出現各種課程推銷，但都還能在睡著與失去耐心之前看完一個段落，這點是很值得效尤的閱讀設計技巧。
討論的主題分成七大部分：
Section 1 - Career / Section 2 - Marketing Yourself 這兩部份討論的事情差不多，主要觀點是：把自己當成事業經營。
每個人的人生想成就的事物不盡相同，但大致上不出「創業」、「職員」、「自由工作者」這三種工作型態，每種工作型態都有其優缺點，沒有最好的選擇，只有最適合、最自在的選擇。制定目標的技巧：由大至小，先抓大方向，然後再去規劃要怎樣分階段性地往大方向前進，在執行計畫目標的過程當中，也不斷地去重新思考「目前的走向」是不是在往「想要的目標」前進，不斷地修正、不斷地思考，減少瞎忙的狀態。
每個人的人生想成就的事物不盡相同，但大致上不出「創業」、「職員」、「自由工作者」這三種工作型態，每種工作型態都有其優缺點，沒有最好的選擇，只有最適合、最自在的選擇。制定目標的技巧：由大至小，先抓大方向，然後再去規劃要怎樣分階段性地往大方向前進，在執行計畫目標的過程當中，也不斷地去重新思考「目前的走向」是不是在往「想要的目標」前進，不斷地修正、不斷地思考，減少瞎忙的狀態。
把自己當成事業經營，適當時候要勇於承擔風險，即使是受僱，心態上也應該將工作表現視為擦亮自己「工程師專業」這塊招牌的方法之一。心境不同，面對困難的態度也會有所不同。
除了砥礪自己的正直人格之外，也要適當地行銷自己的工作能力，名聲資產的累積管道除了被動地讓共事的同事發掘之外，可以積極地利用自媒體增加自身技術能力的曝光度，對公司內部分享技術心得、寫 blog 文章、參與 open source 專案、錄製 youtube 教學影片、參加 conference 或 meetup 活動，用開放地態度分享自己的心得，和業界的其他工程師教學相長營造正循環，累積一些口碑的被動收入（？
Section 3 - Learning 作者提出了一套學習的方法論，大致上是：
 了解領域範疇的大輪廓 制定學習目標 定義目標達成標準 搜集學習的資源（書、演講、課程） 制定學習計畫 過濾資源 學習可以開始動手的最小幅度知識 透過實際使用學習到的知識做一些有用的事情 第 8 步驟撞牆的時候回過頭去繼續補充所需要的進階知識 透過教學他人來融會貫通學習到的知識內容  個人覺得學習陌生領域最困難的入門點在於「不知道自己目前不知道什麼」、「不知道自己應該要先知道什麼」，所以步驟 1~6 其實已經有點「雞生蛋、蛋生雞」，有時候會遇到選一本很多人推薦的書開始讀了以後，陷入書裡面額外提到的各種細節而無法前進（其實大多時候是那種書都很厚重本身就有一種難以征服的心理壓力），又或者是努力地做了一堆「入門」練習然後就卡住無法自己融會貫通地應用在想做的專案上。
我後來發現一個簡單的方法，可以不用在學習之前就花時間搜集資料跟理解當下看再多也看不懂的材料，那就是 Udemy 的課程（或是其他已經整理好的學習計畫），特別是一些透過實作來做教學的程式課，選一些「看來像自己專案需要之技術」、「對於某特定技術的簡介與案例操演」類課程，跟著課程的模組實際動手做，不錯的課程設計已經把步驟 1~6 給完成，直接進入 7~8 階段。最後透過在自己的自媒體上分享所學到的知識內容，重新在腦中組織一次剛塞進去不久的知識，順便累積曝光資產，有時候遇到新的問題要回去查找資料時，自己寫的 blog 文章也會意外成為不錯的參考資料。
        </p>
    </div>
</a>

		
	</div>
	
	<div class="pagination">
		
		
			<a href="/tags/coding/page/2/" class="right arrow">&#8594;</a>
		
	
		<span>1</span>
	</div>
</main>


        		<footer>
			
			<span>
			&copy; <time datetime="2020-11-06 14:02:59.330207 &#43;0800 CST m=&#43;0.265934088">2020</time> Ravi Wu. 
			</span>
		</footer>

    </body>
</html>
