<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>coding on Ravi Wu</title>
    <link>https://raviwu.github.io/tags/coding/</link>
    <description>Recent content in coding on Ravi Wu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-TW</language>
    <copyright>Copyright © 2020 | Ravi Wu</copyright>
    <lastBuildDate>Wed, 28 Oct 2020 12:05:03 +0800</lastBuildDate><atom:link href="https://raviwu.github.io/tags/coding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go | 型別（Type）</title>
      <link>https://raviwu.github.io/posts/go-type/</link>
      <pubDate>Wed, 28 Oct 2020 12:05:03 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/go-type/</guid>
      <description>Go 的型別（Type）可以讓編譯器知道兩樣資訊：
 需要使用的記憶體大小 這些記憶體所代表的內容  以內建的型別為例：
   型別 記憶體大小 內容     int64 8 bytes 整數   float32 4 bytes IEEE-754 浮點數   bool 1 byte true OR false    有一些型別所代表的內容會跟著 build 機器的不同架構有所差異，例如同樣的 int 在 64 位元電腦裡佔 8 bytes 但在 32 位元電腦裡只佔 4 bytes。</description>
    </item>
    
    <item>
      <title>Go | Map</title>
      <link>https://raviwu.github.io/posts/go-map/</link>
      <pubDate>Mon, 26 Oct 2020 14:42:56 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/go-map/</guid>
      <description>Go 的 map 是鍵值對的資料結構。
// 宣告一個空白 map colors := map[string]string{} // 加入或修改鍵值對 colors[&amp;#34;Yello&amp;#34;] = &amp;#34;#cc8500&amp;#34; // 刪除鍵值（鍵不存在時並不會噴錯誤） delete(colors, &amp;#34;Red&amp;#34;) // 宣告一個空 map var numbers map[int]string numbers[1] = &amp;#34;One&amp;#34; // panic: runtime error: assignment ot entry in nil map 檢查鍵是否存在，如果指定的鍵不存在，會回傳零值給 value</description>
    </item>
    
    <item>
      <title>Go | 切片（Slice）</title>
      <link>https://raviwu.github.io/posts/go-slice/</link>
      <pubDate>Mon, 26 Oct 2020 13:14:21 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/go-slice/</guid>
      <description>切片（Slice）是操作其指向之陣列（Array）的物件。
[指標|長度|最大長度] // 切片 | [1,2,3,4,5] // 陣列 切片的初始化 // 宣告一個長度與最大長度都是 5 的字串陣列 slice1 := make([]string, 5) // 宣告一個長度為 3 最大長度為 5 的整數陣列 slice2 := make([]int, 3, 5) 長度不能大於最大長度，不然編譯器會噴錯誤。一般來說，宣告切片的同時也會同時賦值：</description>
    </item>
    
    <item>
      <title>Go | 陣列（Array）</title>
      <link>https://raviwu.github.io/posts/go-array/</link>
      <pubDate>Mon, 26 Oct 2020 11:36:46 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/go-array/</guid>
      <description>Go 的陣列是連續空間內儲存了固定數目之相同型別物件的容器。當使用 var array [5]int 宣告時，陣列內儲存的型別或者長度都不能再改變，如果需要更多的空間來儲存新的物件，需要宣告一個新的陣列後把原先的值搬過去新的陣列。
在 Go 語言中宣告新的變數且無賦值時，這些變數所指向的物件都會以其零值（Zero Value）初始化。有關於 Go 的零值，請參考這邊。常用的零值：
   類型 零值     數值 0   布林值 false   字串 &amp;quot;&amp;quot;    初始化陣列的同時賦值 // 宣告一個 array1 變數的 int 陣列，長度為 5 且值依序分別為 1,2,3,4,5 array1 := [5]int{1,2,3,4,5} // 宣告一個 array2 變數的 int 陣列，長度為 5 且值依序分別為 0,1,2,0,0 array2 := [5]int{1: 1, 2: 2} // 宣告一個 array3 變數的 int 陣列，長度為取決於賦值內容 // 如以下 array3 的長度為 3 array3 := [.</description>
    </item>
    
    <item>
      <title>InputStream 、 DataInputStream 與 BufferedInputStream</title>
      <link>https://raviwu.github.io/posts/java-inputstream-datainputstream-and-bufferedinputstream/</link>
      <pubDate>Fri, 11 Sep 2020 13:46:57 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/java-inputstream-datainputstream-and-bufferedinputstream/</guid>
      <description>Java 有很多不同的 InputStream 類別，老是搞不清楚，InputStream、DataInputStream跟BufferedInputStream最近出現在我看的書的練習題裡，一些從 Java Doc (1.8) 文件中拉出來的相關連結：
 Closeable FilterInputStream InputStream DataInputStream BufferedInputStream  InputStream是抽象類別，實踐了Closeable，所以可以當成try with resource裡的資源。類別方法裡定義了InputStream.nullInputStream()可以產生空的InputStream。另外也規範所有實作子類別必須提供public int read() throws IOException方法來回傳下一個 byte 的內容。</description>
    </item>
    
    <item>
      <title>泛型 Java Functional Interface 的特規化</title>
      <link>https://raviwu.github.io/posts/java-generic-functional-interface-specilization/</link>
      <pubDate>Fri, 11 Sep 2020 13:44:04 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/java-generic-functional-interface-specilization/</guid>
      <description>如果某個特殊型別的 Functional Interface 常常被使用時，有時候直接宣告型別會比較方便引用。可以透過兩種方式來做特規，介面與抽象類別：
Generic Functional Interface
@FunctionalInterface public interface TwoArgsProcessor&amp;lt;X&amp;gt; { X process(X arg1, X arg2); } 介面（Interface）
@FunctionalInterface public interface TwoIntsProcessor extends TwoArgsProcessor&amp;lt;Integer&amp;gt; { } 抽象類別（Abstract Class）</description>
    </item>
    
    <item>
      <title>使用複合條件來判斷是否進入下一輪 Java 迴圈</title>
      <link>https://raviwu.github.io/posts/java-use-combo-condition-for-loop/</link>
      <pubDate>Thu, 10 Sep 2020 13:41:31 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/java-use-combo-condition-for-loop/</guid>
      <description>在 Java 迴圈寫法中，假如我想要透過一個外部判斷來提前中斷這個迴圈，之前我習慣寫：
public class Test { public static void main(String[] args) { int [] ints = {1,2,3,4,5}; boolean continueCond = true; for (int i=0; i&amp;lt;ints.</description>
    </item>
    
    <item>
      <title>Windows 裡的類 homebrew 工具： scoop.sh</title>
      <link>https://raviwu.github.io/posts/tools-scoop-sh/</link>
      <pubDate>Fri, 10 Aug 2018 13:39:10 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/tools-scoop-sh/</guid>
      <description>新工作的環境是 Windows 系統，所有的開發工具生態系都要重新摸索。剛開始發現可以用 Git for Windows 裝好後的 console 下平常習慣的 bash 指令後，努力想要自己寫一些 shell script 去自動化開發工具跟環境變數的初始化，簡單的情境下好似都還堪用。
可是如果要安裝的套件都要一個一個手刻 script 好像又有些白癡。
因緣際會下被提點去找其他平台上的類 Homebrew 方案，權衡系統權限低落等實際情況下，好像也只剩 scoop.</description>
    </item>
    
    <item>
      <title>在 RSpec 裡測試 Rake Task</title>
      <link>https://raviwu.github.io/posts/testing-rake-task-in-rspec/</link>
      <pubDate>Sun, 07 May 2017 13:36:08 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/testing-rake-task-in-rspec/</guid>
      <description>最近被 Rake Task 的測試設定搞得一頭霧水，簡單記錄一下測試 Rake Task 的測試設定，以及各種鬼打牆的血淚史：
TL;DR 為了避免各種 task 載入、執行狀態等相互干擾導致 test case 會偶發性失敗，每一次執行 test case 時就去做「載入」、「卸載」會比較沒有鬼打牆狀況出現。
# spec_helper.rb config.before(:each, rake: true) do Rails.</description>
    </item>
    
    <item>
      <title>書摘 | Soft Skills: The software developer&#39;s life manual</title>
      <link>https://raviwu.github.io/posts/notes-soft-skills/</link>
      <pubDate>Wed, 22 Feb 2017 13:28:15 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/notes-soft-skills/</guid>
      <description>公司前輩分享了 Soft Skills: The software developer&amp;rsquo;s life manual 這本書，後來又在 Soft &amp;amp; Share 看到推廣介紹，抱著當休閒讀物的心情來閱讀是很不錯的。
作者 John Z. Sonmez 在這本書中想要涵括的內容實在包山包海，如果對於人生迷惘的捧油，的確只要看了這本書所簡單介紹的內容就大概可以對人生重拾一些希望，也能循著這些主題繼續往深探索。比較特別的是，每個章節的篇幅被設計成大概一篇 Blog 文長度，所以閱讀起來的節奏感很是不錯，即使有些主題令人打哈欠，有些主題不斷地出現各種課程推銷，但都還能在睡著與失去耐心之前看完一個段落，這點是很值得效尤的閱讀設計技巧。</description>
    </item>
    
    <item>
      <title>工具 | Kindle &#34;My Clippings.txt&#34; 的轉檔 gem KCFU</title>
      <link>https://raviwu.github.io/posts/tools-kcfu-for-kindle-clipping/</link>
      <pubDate>Sat, 28 Jan 2017 13:33:09 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/tools-kcfu-for-kindle-clipping/</guid>
      <description>Kindle 的剪貼簿功能雖然在 Kindle 上很好用，但真的要抽出來另外處理書摘的時候還真的麻煩，因為 My Clippings.txt 就是一個很簡單的純文字檔，每次在 Kindle 上面 hightlight / bookmark / notes 時就會依照書的 title 去新增一段特定格式的文字段落，所以如果同時看很多本的時候，打開 My Clippings.txt 會發現裡面就依照 clippings 時序夾雜著來自不同書裡的內容，得再經過一些處理才能分成不同的來源。</description>
    </item>
    
    <item>
      <title>在 Trailblazer 的 Policy 中透過客制 Exception 來處理複雜的「錯誤回應」</title>
      <link>https://raviwu.github.io/posts/customize-error-handlement-in-trailblazer-policy/</link>
      <pubDate>Sat, 14 Jan 2017 13:25:31 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/customize-error-handlement-in-trailblazer-policy/</guid>
      <description>為了盡量貼近 Trailblazer 的設計概念，許多原先會透過 Controller before_action 去處理的權限管控，盡量都搬進 Trailblazer 的 Policy 裡。
Policy 採用類似 Pundit 的語法，典型的 Policy 如下：
class Thing::Policy def initialize(user, thing) @user, @thing = user, thing end def create?</description>
    </item>
    
    <item>
      <title>初探 Trailblazer 框架</title>
      <link>https://raviwu.github.io/posts/elementary-trailblazer/</link>
      <pubDate>Sat, 07 Jan 2017 13:23:29 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/elementary-trailblazer/</guid>
      <description>最近公司的 Rails 專案試用了 Trailblazer 這套整理 Rails 程式碼的框架。（目前使用的是 1.1 版）
Trailblazer 是擺在 Rails 上的一套工具，雖然有本專書可以翻找，但實際上就是個自成一格的整理程式碼套路，除了要學新的 DSL 外，在 API 文件沒有寫得非常詳細，加上使用者也沒多到可以 stackoverflow 的情況下，假如開發需求和設計者 Nick Sutterer 設想的情況不一樣時，小小撞牆是難免的。</description>
    </item>
    
    <item>
      <title>筆記 | Practical Object-Oriented Design in Ruby (POODR)</title>
      <link>https://raviwu.github.io/posts/notes-of-poodr/</link>
      <pubDate>Tue, 03 Jan 2017 13:20:41 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/notes-of-poodr/</guid>
      <description>Practical Object-Oriented Design in Ruby (POODR) 不會很厚，循序漸進地介紹物件導向設計的各種重要概念，而且範例用的是 Ruby 來解說，挺親切的。
除了各種設計原則之外，也簡要解釋了 Inheritance / Module / Composition 的使用時機與差異。
最後一章介紹測試原則，除了說明一般的測試原則之外（例如主要應測試 public interface / incoming message / outgoing command ），也很清楚地說明要怎樣去分別把不同的測試責任分在 module / test double / test class 上，以及讓 test double 與實際的程式碼同步的技巧，可以反覆閱讀的參考書。</description>
    </item>
    
    <item>
      <title>利用 find_in_batches 在 Rails 做跨資料庫的資料移轉操作</title>
      <link>https://raviwu.github.io/posts/use-find-in-batches-during-migration/</link>
      <pubDate>Fri, 02 Sep 2016 05:05:44 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/use-find-in-batches-during-migration/</guid>
      <description>在處理跨資料庫搬動並且需要一筆一筆資料去做各種運算處理時，最直覺的方式，是把表格裡的所有資料通通透過 ORM 撈到 ActiveRecord::Association 陣列裡，再用 each 去做操作：
User.all.each do |user| user.email = &amp;#34;assign@new.email&amp;#34; ... end 但由於 Rails 會需要先去建立這些 objects，如果資料筆數很多的話，一次通通撈出來會佔用過多不必要的記憶體，可以使用 find_in_batches 做批次處理，減少系統 RAM 的負擔。</description>
    </item>
    
    <item>
      <title>使用 Google Sheets API 拉資料到 Rails APP 裡</title>
      <link>https://raviwu.github.io/posts/pull-data-to-rails-from-google-sheet/</link>
      <pubDate>Sat, 09 Jul 2016 05:17:26 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/pull-data-to-rails-from-google-sheet/</guid>
      <description>Google Sheets 很好用，一些程式中需要跨部門討論的字串定義，又或者是需要讓不方便存取原始碼的同事也能清楚知道原始碼裡部分設定字串的時候，通常都可以利用 Google Sheet 來做討論平台，再以 Google Sheets 上面的文件為基礎，匯入主程式中做各種處理，確保主程式的內容與 Google Sheets 上的內容同步。
要匯入 Google Sheets 內容到程式裡最簡單的方式，是輸出 csv 後寫個小 script 去讀取 csv 資料，轉成 Array 後就能靈活使用。</description>
    </item>
    
    <item>
      <title>在 rails 上實作轉移 Parse 手機推播服務到 Amazon SNS</title>
      <link>https://raviwu.github.io/posts/migrate-push-notification-from-parse-to-aws-sns/</link>
      <pubDate>Fri, 24 Jun 2016 05:05:44 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/migrate-push-notification-from-parse-to-aws-sns/</guid>
      <description>簡要說明 為了避免使用者因服務轉換而被迫強制更新，移轉過程採用漸進方式。
如果不需要如此痛苦的同時使用兩種服務的捧油，可以參考這一篇的實作，直接用 AWS Mobile Hub 的服務做批次資料移轉。
由於在轉換期需要同時支援兩邊服務運作，又要避免使用者重複收到相同的推播，需要實作「對同一裝置擇一服務進行推播」。本篇實作的概念是，使用者只有在用新版本的 APP 登入時，伺服器才會從 APP 取得 device_token 去註冊 Amazon SNS endpoint_arn，同時刪除 Parse 服務上的使用者的所有 Installation 紀錄。</description>
    </item>
    
    <item>
      <title>Rails grape API 上實作 JWT 多重登入</title>
      <link>https://raviwu.github.io/posts/implement-jwt-in-grape-api/</link>
      <pubDate>Fri, 10 Jun 2016 05:05:44 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/implement-jwt-in-grape-api/</guid>
      <description>多重登入的需求，在服務本身允許「跨裝置體驗」或者是「接受不同 request agent (APP request / mobile browser)」的時候顯得重要。
理想情況下，可以讓使用者在介面上面清楚知道目前帳號的登入狀態，並在登入數超過服務上限的時候，讓使用者自己選擇要移除登入授權的裝置，使用者流程大概會像（這篇文）那樣，要做到類似參考連結這樣的管理介面，需要我目前還不會的前端的配合建置與基本的 session 管理 API。本篇只先建置允許使用多重登入的資料結構與登入驗證 API。
選擇用 JWT (Jason Web Token) 作為主要的憑證溝通，優點有一些：
 透過加密 payload 來比對資料庫內容的方式，可以不用在資料表中「直接存入」與憑證相關的訊息，加密跟解密只要透過協定就能進行調整。 payload 裡面塞入的訊息可以自訂，在各服務跟裝置之間交換加密過後的使用者資料。 signing key / protocol 可以在有資安疑慮時更換。  使用 Devise 的 Rails 捧油也可參考 devise_token_auth 這個 gem，整合效果在文件上面看起來很完善，但因為目前我手邊的系統絕大多數的 request 都來自 grape API endpoint ，比較過後，跟搞懂並駕馭 devise 設定比起來，我還是選擇自刻 JWT 較節省開發時間。</description>
    </item>
    
    <item>
      <title>Rails 中使用 Paperclip 存 URI 附件</title>
      <link>https://raviwu.github.io/posts/use-paperclip-to-store-uri-in-rails/</link>
      <pubDate>Thu, 12 May 2016 04:38:49 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/use-paperclip-to-store-uri-in-rails/</guid>
      <description>使用 Rails APP + Paperclip Gem 做附件存取系統，靜態檔案的資料夾格式預設是跟著 id 跑（ /000/000/000/ 九碼化的 ID 切成 3 階資料夾），最近因為要做資料庫合併，大批的資料會被賦予新的 ID，原先放在 AWS S3 上面的靜態資料夾結構就會 mapping 錯誤，必須要依照新的 ID 去存放相對應的資料夾結構。</description>
    </item>
    
    <item>
      <title>程設風格 | 早期終止執行</title>
      <link>https://raviwu.github.io/posts/early-termination/</link>
      <pubDate>Fri, 15 Apr 2016 04:22:50 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/early-termination/</guid>
      <description>剛開始寫程式的時候，以為所謂邏輯判斷就是很多個若 A 則 B 包起來的複雜地圖。這樣的程式碼，很容易因為邏輯判斷太過複雜，很難一眼就看到到底目前程式會跑到哪一個 if 分支裡面執行。
taget = Dog.new if target.is_a?(Animal) if target.has_four_legs? if target.is_a?(Dog) puts &amp;#34;wolf!&amp;#34; else puts &amp;#34;four leg animal can say yeah&amp;#34; end else puts &amp;#34;don&amp;#39;t know what that is&amp;#34; end else puts &amp;#34;don&amp;#39;t know what that is&amp;#34; end =&amp;gt; &amp;#34;wolf!</description>
    </item>
    
    <item>
      <title>終端機工具</title>
      <link>https://raviwu.github.io/posts/command-line-tools-notes/</link>
      <pubDate>Sun, 27 Mar 2016 04:07:31 +0800</pubDate>
      
      <guid>https://raviwu.github.io/posts/command-line-tools-notes/</guid>
      <description>轉型後端工程師的路上，看了很多教學，裝了很多套件，用過很多軟體。目前用得還算不手殘的工具只有終端機（terminal）跟文本編輯器（text editor）。
因為要經常性切換不同的 Git Branch，MacOX 本來附掛的 terminal 顯得有點陽春，需要極大注意力才能清楚知道自己究竟目前身在何處又在哪支 branch 裡。
先烈做了很多很棒的工具改善工作體驗與視覺效果，iTerm 2 很是不錯，搭配上一些快捷熱鍵可以有效增加效率。
Shortcut of iTerms2 windows and tabs command + T to open new tab</description>
    </item>
    
  </channel>
</rss>
